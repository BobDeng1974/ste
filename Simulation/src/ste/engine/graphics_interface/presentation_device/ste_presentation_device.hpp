//	StE
// © Shlomi Steinberg 2015-2016

#pragma once

#include <stdafx.hpp>

#include <ste_window.hpp>
#include <vk_physical_device_descriptor.hpp>

#include <ste_engine_exceptions.hpp>
#include <ste_gl_context_creation_parameters.hpp>
#include <ste_presentation_surface.hpp>
#include <ste_gl_context.hpp>
#include <ste_gl_device_queue.hpp>

#include <memory>
#include <vector>
#include <atomic>

namespace StE {
namespace GL {

template <typename QueueProtocol>
class ste_presentation_device {
private:
	using queue_t = std::unique_ptr<ste_gl_device_queue>;

private:
	const ste_gl_presentation_device_creation_parameters parameters;
	vk_logical_device presentation_device;
	ste_presentation_surface presentation_surface;

	std::uint32_t tick_count{ 0 };
	std::vector<ste_gl_queue_descriptor> queue_descriptors;
	std::vector<queue_t> device_queues;
	unsigned main_queue_idx{ 0 };
	unsigned compute_queue_idx{ 0 };
	unsigned transfer_queue_idx{ 0 };

private:
	static thread_local ste_presentation_surface::acquire_next_image_return_t acquired_presentation_image;

public:
	static auto &next_presentation_image() { return acquired_presentation_image; }

private:
	static auto create_vk_virtual_device(const GL::vk_physical_device_descriptor &physical_device,
										 const VkPhysicalDeviceFeatures &requested_features,
										 std::vector<const char*> device_extensions = {}) {
		// Add required extensions
		device_extensions.push_back("VK_KHR_swapchain");

		// Request queues based on supplied protocol
		std::vector<VkDeviceQueueCreateInfo> queues_create_infos;
		auto queue_descriptors = QueueProtocol::queues_for_physical_device(physical_device);
		queues_create_infos.resize(queue_descriptors.size());
		for (int i = 0; i < queue_descriptors.size(); ++i)
			queues_create_infos[i] = queue_descriptors[i].create_device_queue_create_info();

		// Create logical device
		GL::vk_logical_device device(physical_device,
									 requested_features,
									 queues_create_infos,
									 device_extensions);

		return device;
	}

	void setup_queues_indices(const std::vector<ste_gl_queue_descriptor> &queues) {
		main_queue_idx =
			std::find_if(queues.begin(), queues.end(),
						 [](const ste_gl_queue_descriptor &q) { return q.usage == ste_gl_queue_usage::main_queue; }) - queues.begin();
		assert(main_queue_idx < queues.size());

		compute_queue_idx =
			std::find_if(queues.begin(), queues.end(),
						 [](const ste_gl_queue_descriptor &q) { return q.usage == ste_gl_queue_usage::compute_queue; }) - queues.begin();
		transfer_queue_idx =
			std::find_if(queues.begin(), queues.end(),
						 [](const ste_gl_queue_descriptor &q) { return q.usage == ste_gl_queue_usage::data_transfer_queue; }) - queues.begin();

		if (compute_queue_idx == queues.size())
			compute_queue_idx = std::find_if(queues.begin(), queues.end(),
											 [](const ste_gl_queue_descriptor &q) { return q.usage == ste_gl_queue_usage::main_queue; }) - queues.begin();
		if (transfer_queue_idx == queues.size())
			transfer_queue_idx = std::find_if(queues.begin(), queues.end(),
											  [](const ste_gl_queue_descriptor &q) { return q.usage == ste_gl_queue_usage::main_queue; }) - queues.begin();
	}

	void create_queues() {
		std::vector<queue_t> q;
		q.reserve(queue_descriptors.size());
		for (auto &d : queue_descriptors)
			q.push_back(std::make_unique<queue_t::element_type>(presentation_device, 
																d, 
																get_command_buffers_count()));

		device_queues = std::move(q);
	}

	void recreate_swap_chain() {
		// Destroy queues, this will wait for all queue threads and then wait for all queues to finish processing,
		// allowing us to recreate the swap chain and queue safely.
		device_queues.clear();

		// Recreate swap chain
		presentation_surface.recreate_swap_chain();
		// And queues
		create_queues();
	}

	auto get_current_tick_command_buffer_index() const {
		return tick_count % get_command_buffers_count();
	}

public:
	ste_presentation_device(const ste_gl_presentation_device_creation_parameters &parameters,
							const ste_gl_context &gl_ctx,
							const ste_window &presentation_window)
		: parameters(parameters),
		presentation_device(create_vk_virtual_device(parameters.physical_device,
													 parameters.requested_device_features,
													 parameters.additional_device_extensions)),
		presentation_surface(parameters, &presentation_device, presentation_window, gl_ctx.instance())
	{
		// Read queue descriptors as generated by the supplied protocol
		queue_descriptors = QueueProtocol::queues_for_physical_device(parameters.physical_device);
		// Read indices of our queues
		setup_queues_indices(queue_descriptors);

		// Create queues
		create_queues();
	}
	~ste_presentation_device() noexcept {}

	ste_presentation_device(ste_presentation_device &&) = default;
	ste_presentation_device &operator=(ste_presentation_device &&) = default;

	/**
	*	@brief	Polls windowing system events. Will resize/recreate swap chain if necessary.
	*			Might stall till a command buffer becomes available.
	*/
	void tick() {
		glfwPollEvents();

		bool recreate = presentation_surface.test_and_clear_recreate_flag();
		if (recreate) {
			// Recreate swap chain and queues
			recreate_swap_chain();
		}

		// Increase tick count
		++tick_count;

		// And reset the appropriate command buffers
		auto buffer_idx = get_current_tick_command_buffer_index();
		for (auto &q : device_queues) {
			// Once in a while release command buffer resources to avoid command buffers growing indefinitely
			bool release = (tick_count + buffer_idx*100) % 1000 == 0;
			q->reset(buffer_idx, release);
		}
	}

	/**
	*	@brief	Enqueues a task on the main queue to acquire next presentation image and resize/recreate swap chain if necessary.
	*			The task will save the presentation image information in the thread_local variable, which will be consumed on 
	*			next call to present.
	*
	*	@param presentation_image_ready_semaphore	Semaphore to be signaled when next presentation image is ready to be drawn to.
	*/
	void acquire_presentation_image(const vk_semaphore &presentation_image_ready_semaphore) {
		enqueue_main([this, presentation_image_ready_semaphore](std::uint32_t index) {
			// Acquire next presenation image
			acquired_presentation_image = presentation_surface.acquire_next_swapchain_image(presentation_image_ready_semaphore);
		});
	}

	/**
	*	@brief	Presents the presentation image.
	*
	*	@param rendering_ready_semaphore	Semaphore to be signaled when rendering to the presentation image is complete.
	*/
	void present(const vk_semaphore &rendering_ready_semaphore) {
		enqueue_main([this, rendering_ready_semaphore](std::uint32_t index) {
			if (acquired_presentation_image.image != nullptr) {
				this->presentation_surface.present(acquired_presentation_image.image_index,
												   *device_queues[main_queue_idx],
												   rendering_ready_semaphore);
			}
		});
	}

	/**
	*	@brief	Enqueues submission of the command buffer of the main queue
	*
	*	@param	wait_semaphores		See vk_queue::submit
	*	@param	signal_semaphores	See vk_queue::submit
	*/
	template <typename R>
	std::future<R> submit_main_command_buffer(const std::vector<std::pair<vk_semaphore*, VkPipelineStageFlags>> &wait_semaphores,
											  const std::vector<vk_semaphore*> &signal_semaphores) const {
		return device_queues[main_queue_idx]->submit(get_current_tick_command_buffer_index(),
													 wait_semaphores,
													 signal_semaphores);
	}
	/**
	*	@brief	Enqueues submission of the command buffer of the compute queue
	*
	*	@param	wait_semaphores		See vk_queue::submit
	*	@param	signal_semaphores	See vk_queue::submit
	*/
	template <typename R>
	std::future<R> submit_compute_command_buffer(const std::vector<std::pair<vk_semaphore*, VkPipelineStageFlags>> &wait_semaphores,
												 const std::vector<vk_semaphore*> &signal_semaphores) const {
		return device_queues[compute_queue_idx]->submit(get_current_tick_command_buffer_index(),
														wait_semaphores,
														signal_semaphores);
	}
	/**
	*	@brief	Enqueues submission of the command buffer of the data transfer queue
	*
	*	@param	wait_semaphores		See vk_queue::submit
	*	@param	signal_semaphores	See vk_queue::submit
	*/
	template <typename R>
	std::future<R> submit_transfer_command_buffer(const std::vector<std::pair<vk_semaphore*, VkPipelineStageFlags>> &wait_semaphores,
												  const std::vector<vk_semaphore*> &signal_semaphores) const {
		return device_queues[transfer_queue_idx]->submit(get_current_tick_command_buffer_index(),
														 wait_semaphores,
														 signal_semaphores);
	}

	/**
	*	@brief	Enqueues a task on the main queue. The task will be scheduled with a FIFO policy on the
	*			queue's thread.
	*
	*	@param f	Task to enqueue. Must take a single parameter of type 'const vk_command_buffer&', which is the
	*				command buffer on which the task should record device commands.
	*/
	template <typename R>
	std::future<R> enqueue_main(ste_gl_device_queue::enqueue_task_t<R> &&f) const {
		return device_queues[main_queue_idx]->enqueue_with_buffer_idx(std::move(f), 
																	  get_current_tick_command_buffer_index());
	}
	/**
	*	@brief	Enqueues a task on the compute queue. The task will be scheduled with a FIFO policy on the
	*			queue's thread.
	*
	*	@param f	Task to enqueue. Must take a single parameter of type 'const vk_command_buffer&', which is the
	*				command buffer on which the task should record device commands.
	*/
	template <typename R>
	std::future<R> enqueue_compute(ste_gl_device_queue::enqueue_task_t<R> &&f) const {
		return device_queues[compute_queue_idx]->enqueue_with_buffer_idx(std::move(f), 
																		 get_current_tick_command_buffer_index());
	}
	/**
	*	@brief	Enqueues a task on the data transfer queue. The task will be scheduled with a FIFO policy on the
	*			queue's thread.
	*
	*	@param f	Task to enqueue. Must take a single parameter of type 'const vk_command_buffer&', which is the
	*				command buffer on which the task should record device commands.
	*/
	template <typename R>
	std::future<R> enqueue_transfer(ste_gl_device_queue::enqueue_task_t<R> &&f) const {
		return device_queues[transfer_queue_idx]->enqueue_with_buffer_idx(std::move(f), 
																		  get_current_tick_command_buffer_index());
	}

	auto get_command_buffers_count() const {
		return presentation_surface.swap_chain_images_count();
	}
	auto& device() const { return presentation_device; }
};

}
}
