
#type compute
#version 450

#include <voxels.glsl>
#include <voxels_voxelize.glsl>

layout(local_size_x = voxelizer_work_group_size) in;


layout(std430, set=1, binding=2) restrict buffer voxel_list_binding {
	voxel_list_element_t voxel_list_buffer[];
};
layout(std430, set=1, binding=3) restrict buffer voxel_list_counter_binding {
	uint voxel_list_buffer_size;
};


void voxelize(uint level, uint chunk_start, uint chunk_end) {
	// Loop over invocation's chunk, traversing and subdividing nodes, and save child pointer
	for (uint i = chunk_start; i < chunk_end; ++i) {
		uint node = level == 0 ? 
			voxel_root_node : 
			imageLoad(voxels, voxels_image_coords(voxel_list_buffer[i].voxel_node)).x;
		vec3 v = vec3(voxel_list_buffer[i].node_x, voxel_list_buffer[i].node_y, voxel_list_buffer[i].node_z);

		voxel_voxelize(v, 
					   node,
					   level,
					   voxel_list_buffer[i].data);
		
		if (level != voxel_leaf_level - 1) {
			// For leaf nodes, no need to write out values
			voxel_list_buffer[i].node_x = v.x;
			voxel_list_buffer[i].node_y = v.y;
			voxel_list_buffer[i].node_z = v.z;
			voxel_list_buffer[i].voxel_node = node;
		}
	}

	memoryBarrierBuffer();
	barrier();
}

void main() {
	const uint invocation_id = gl_LocalInvocationID.x;
	const uint voxel_list_chunk_size = (voxel_list_buffer_size + voxelizer_work_group_size - 1) / voxelizer_work_group_size;

	// Clear root node
	const uint root_binary_map_size = voxel_binary_map_size(voxel_Pi);
	const uint clears_per_worker = (root_binary_map_size + voxelizer_work_group_size - 1) / voxelizer_work_group_size;
	const uint root_binary_map_offset = voxel_node_binary_map_offset(voxel_Pi);
	for (uint i=clears_per_worker * invocation_id; i<min(root_binary_map_size, clears_per_worker * (invocation_id + 1)); ++i)
		imageStore(voxels, voxels_image_coords(root_binary_map_offset + i), uint(0).xxxx);
	
	// Divide voxel list into even sized chunks
	const uint chunk_start = invocation_id * voxel_list_chunk_size;
	const uint chunk_end = min((invocation_id + 1) * voxel_list_chunk_size, voxel_list_buffer_size);
	
	// Step 1 -- Subdivide.
	for (uint l=0; l<voxel_leaf_level; ++l) {
		voxelize(l,
				 chunk_start, chunk_end);
		
		memoryBarrierBuffer();
		barrier();
	}

	// Step 2 -- Upsample
	//for (uint )
}
