
#type compute
#version 450

#include <voxels.glsl>
#include <voxels_voxelize.glsl>

layout(local_size_x = voxelizer_work_group_size) in;

void main() {
	// Divide voxel list into even sized chunks
	uint invocation_id = gl_LocalInvocationID.x;
	uint voxel_list_chunk_size = (voxel_list_buffer_size + voxelizer_work_group_size - 1) / voxelizer_work_group_size;
	
	uint chunk_start = invocation_id * voxel_list_chunk_size;
	uint chunk_end = min((invocation_id + 1) * voxel_list_chunk_size, voxel_list_buffer_size);
	
	// Root node
	// Loop over invocation's chunk, traversing and subdividing nodes, and save child pointer.
	for (uint i = chunk_start; i < chunk_end; ++i) {
		uint node = voxel_root_node;
		vec3 v = voxel_list_buffer[i].p;
		voxel_voxelize(v, 
					   node,
					   0);

		voxel_list_buffer[i].voxel_coord = v;
		voxel_list_buffer[i].voxel_node = node;
	}
	
	memoryBarrierBuffer();
	barrier();
	
	// Intermediate level nodes
	for (uint l=1; l<voxel_leaf_level - 1; ++l) {
		// Loop over invocation's chunk
		for (uint i = chunk_start; i < chunk_end; ++i) {
			uint node = voxel_buffer[voxel_list_buffer[i].voxel_node];
			voxel_voxelize(voxel_list_buffer[i].voxel_coord, 
						   node, 
						   l);

			voxel_list_buffer[i].voxel_node = node;
		}
		
		memoryBarrierBuffer();
		barrier();
	}
	
	// Leaf node
	for (uint i = chunk_start; i < chunk_end; ++i) {
		uint node = voxel_buffer[voxel_list_buffer[i].voxel_node];
		vec3 v = voxel_list_buffer[i].voxel_coord;
		voxel_voxelize(v, 
					   node, 
					   voxel_leaf_level - 1);
	}
		
	memoryBarrierBuffer();
	barrier();

	// Build ropes
	for (uint i = chunk_start; i < chunk_end; ++i) {
		vec3 v = voxel_list_buffer[i].p;
		voxel_voxelize_traverse_generating_ropes(v);
	}
}
