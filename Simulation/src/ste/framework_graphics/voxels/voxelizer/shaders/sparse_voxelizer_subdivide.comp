
#type compute
#version 450

#include <voxels.glsl>
#include <voxels_voxelize.glsl>

layout(local_size_x = voxelizer_work_group_size) in;


layout(std430, set=1, binding=0) restrict buffer voxels_assembly_list_binding {
	voxel_list_element_t voxel_assembly_list_buffer[];
};
layout(std430, set=1, binding=1) restrict readonly buffer voxels_assembly_list_counter_binding {
	uint counter;
};
layout(std430, set=1, binding=9) restrict writeonly buffer brick_assembly_list_binding {
	bricks_list_element_t bricks_assembly_list_buffer[];
};
layout(std430, set=1, binding=10) restrict buffer brick_assembly_counter_binding {
	uint bricks_assembly_list_counter;
};


void voxelize(uint level, uint res, uint chunk_start, uint chunk_end) {
	// Loop over invocation's chunk, traversing and subdividing nodes, and save child pointer
	for (uint i = chunk_start; i < chunk_end; ++i) {
		const uvec2 packed_coords = voxel_assembly_list_buffer[i].voxel_node.xy;

		// Read current level node
		uint node = level == 0 ? 
			voxel_root_node : 
			imageLoad(voxels, voxels_image_coords(voxel_assembly_list_buffer[i].voxel_node.z)).x;
		// Extrapolate position in node
		const uvec3 pos = voxels_unpack_coordinates(packed_coords);
		const uvec3 v = (pos >> res) & voxel_mask;
		
		// Subdivide
		bool subdivided;
		node = voxel_voxelize(node, 
							  v,
							  level,
							  subdivided);
		
		// Save pointer to child node
		voxel_assembly_list_buffer[i].voxel_node.z = node;

		if (subdivided && level == voxel_leaf_level - 1) {
			// Store node address and coordinates
			bricks_list_element_t e;

			uint idx = atomicAdd(bricks_assembly_list_counter, 1);
			e.node = packed_coords;
			
			bricks_assembly_list_buffer[idx] = e;
		}
	}
}

void write_leaf_data(uint res, uint chunk_start, uint chunk_end) {
	for (uint i = chunk_start; i < chunk_end; ++i) {
		// Read address of node
		const uint ptr = voxel_assembly_list_buffer[i].voxel_node.z;
		const uint node = imageLoad(voxels, voxels_image_coords(ptr)).x;
		// Extrapolate position in node
		const uvec3 pos = voxels_unpack_coordinates(voxel_assembly_list_buffer[i].voxel_node.xy);
		const uvec3 v = (pos >> res) & voxel_mask;

		// Blend data
		voxel_voxelize_blend_user_data(node,
									   v,
									   voxel_assembly_list_buffer[i].data);
	}
}

void main() {
	const uint invocation_id = gl_LocalInvocationID.x;
	
	// Divide voxel list into even sized chunks
	const uint voxel_list_chunk_size = (counter + voxelizer_work_group_size - 1) / voxelizer_work_group_size;
	const uint chunk_start = invocation_id * voxel_list_chunk_size;
	const uint chunk_end = min((invocation_id + 1) * voxel_list_chunk_size, counter);
	
	const uint n = voxel_leaf_level - 1;
	
	// Stage 1 -- Subdivide nodes
	for (uint l=0; l<voxel_leaf_level; ++l) {
		const uint level_resolution = voxel_P * (n - l);

		// Subdivide
		voxelize(l, level_resolution,
				 chunk_start, chunk_end);
	
		// Need image barrier for voxel grid and buffer barrier for voxel list.
		memoryBarrier();
		barrier();
	}

	// Stage 2 -- Write data to leafs and blend
	write_leaf_data(0, 
					chunk_start, 
					chunk_end);
}
